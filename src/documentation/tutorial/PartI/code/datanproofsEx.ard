\import datanproofs

-- 1. Write the function 'lookup', which takes a list in List A and a natural number n and returns the n-th element in the list.
--    Note that it is impossible to define such a function without restrictions on n sice n can be greater than the size of the list.
--    Therefore the function should also take a proof that n is in the right range: T (n < length xs).

\func \infix 4 < (x y : Nat) : Bool
  | 0, 0 => false
  | 0, suc y => true
  | suc x, 0 => false
  | suc x, suc y => x < y

\data T (b : Bool) \with
  | true => tt

\func lookup => {?}

-- 2. Implement function replicate for 'vec' and 'Vec' (this function creates the list of a given length filled with a
-- given element).

-- 3. Implement function 'map' for 'vec' and 'Vec'.

-- 4. Implement function 'zipWith' for 'vec' and 'Vec'.
--    The function must take lists of equal lengths.

-- 5. Functions Fin n → A correspond to lists of length n with elements in A.
--    Implement the function that converts an element of Fin n → A to element of Vec A n.

\func coin {A : \Type} {n : Nat} (f : Fin n -> A) : Vec A n => {?}

-- 6. Define the type of matrices and a number of functions for them:

\func Mat (A : \Type) (n m : Nat) : \Type => {?}

-- diagonal matrix with elements e on the diagonal and z at all other positions.

\func diag {A : \Type} (z e : A) (n : Nat) : Mat A n n => {?}

-- transposition

\func transpose {A : \Type} {n m : Nat} (M : Mat A n m) : Mat A m n => {?}

-- addition

\func matAdd {A : \Type} (add : A -> A -> A) (n m : Nat) (M N : Mat A n m) : Mat A n m => {?}

-- multiplication

-- z is neutral under addition.
\func matMul {A : \Type} (z : A) (add mul : A -> A -> A) (n m k : Nat) (M : Mat A n m) (N : Mat A m k) : Mat A n k => {?}

-- 7. Define the type CTree A n of full binary trees of height precisely n, which store elements in internal nodes, but not in leaves.
--    The height of a leaf is 0.

\data CTree (A : \Type) (n : Nat)

-- 8. Define the type Tree A n of binary trees of height at most n, which store elements in internal nodes, but not in leaves.
--    The height of a leaf is 0.

\data Tree (A : \Type) (n : Nat)

-- Define the function that computes the height of a tree.

\func height {A : \Type} (n : Nat) (t : Tree A n) : Fin (suc n) => {?}

-- 9. Define congruence for functions with two arguments via transport.
--    It is allowed to use any functions defined via transport.

\func pmap2 {A B C : \Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' => {?}

-- 10. Prove that 'transport' can be defined via 'pmap' and 'repl' and vice versa.

-- 'repl' says that if two types are equal then there exists a function between them.
-- Define 'repl' via 'transport'.

\func repl {A B : \Type} (p : A = B) (a : A) : B => {?}

-- Define 'transport' via 'repl' and 'pmap'.

\func transport' {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a' => {?}

-- 11. Prove that left = right without using 'transport'.

\func left=right : left = right => {?}

-- 12. Prove that if a = a' and b = b', then (a,b) = (a',b').

\func pairEq {A B : \Type} {a a' : A} {b b' : B} (p : a = a') (q : b = b') : (a,b) = (a',b') => {?}

-- 13. Prove that if p = p', then p.1 = p'.1.

\func projEq {A : \Type} (B : A -> \Type) {p p' : \Sigma (x : A) (B x)} (t : p = p') : p.1 = p'.1 => {?}

